############################## Preparation of the analysis ############################

#Design factors to systematically vary:
#1) Sample size: 200, 400, 800 (nobs) 
#2) Number of items: 12, 24, 36, 48 (nvars) 
#3) Number of latent variables: 4, 6, 8 (factors) 
#4) Answer categories: 2, 4 (ncat)
#5) Misspecifications: 0 or 2,3,4 (misspec0 and misspec)
#6) Type of data: ordinal, mixed-type*
### Initialize the factors of your design:

#HOWEVER: data generation function depends on these 3 factors 
factors <- c(2, 4,6,8) 					          	  #number of latent variables
nobs <- c(200,400,800)                      #sample size
ncat <- c(2,4)                              #number of categories

#???
nvarp <- 6                                  #one set of variables

##Create the simulation design matrix (full factorial)
# Design is a data.frame with all possible combinations of the factor levels
# Each row of the design matrix represents a cell of your simulation design
Design <- expand.grid(factors = factors, nobs = nobs, ncat = ncat)
Design

###Preparation of the analysis:
# If you use R packages that are not standard:
# Install the relevant R packages
#Always use library() to activate the package
### Source the relevant R functions of our example
### These functions are available from:
### https://github.com/Github-MS/Shark/tree/master/Scripts
source("MyDataGeneration.R")
source("Method_new.R")
source("Method_old.R")
source("MyEvaluationPC.R")

################################ My data generating function #################################
MyDataGeneration <- function(factors, nobs, ncat) {
  
  # model specifications
  nvar <- factors*nvarp
  BM <- matrix(c(.8,.8,.7,.7,.6,.6),nrow=1) #factor loadings
  r <- 0.3 # correlation between latent variables
  int <- c(0,0,0,0,0,0) # intercept
  s <- matrix(r, factors, factors) 
  diag(s) <- 1
  # intercepts of the items
  int2 <- rep(int,factors)

  # b is the loadingsmatrix > transposed matrix version
  b <- t(kronecker(diag(factors), BM)) # kronecker computes product of two arrays 
  
    x.mis <- sapply(1:(factors/2), function(x) return(6 + 12*(x-1)))
    y.mis <- sapply(1:(factors/2), function(x) return(2 + 2*(x-1)))
    b[x.mis, y.mis] <- .2
  
  #compute error values (theta matrix)
  ev <- diag(1 - diag(b %*% s %*% t(b)))
  
  #compute sigma (variance-covariance matrix) 
  SIGMA <- b %*% s %*% t(b) + ev  #1's on the diagonal
  
  #simulate data from a Multivariate Normal Distribution
  x <- data.frame(MASS:::mvrnorm(n = nobs, mu = int2, Sigma = SIGMA))
  
  # for 2 answer categories (1 threshold -> 0)
  if (ncat==2) {item.cutpoints <- 
    matrix(c(rep(0,nvar)), ncol=nvar, byrow=TRUE)}			
  
  # for 4 answer categories (3 thresholds -> -1.2, 0, 1.2)
  if (ncat==4) {item.cutpoints <- 
    matrix(c(rep(-1.20,nvar),rep(0,nvar),rep(1.20,nvar)), ncol=nvar, byrow=TRUE)}
  
  #item cutpoints (add boundaries)
  item.cutpoints <- rbind(rep(-Inf, ncol(item.cutpoints)), 
                          item.cutpoints, rep(Inf, ncol(item.cutpoints)))
  
  for(i in 1:ncol(item.cutpoints)){ 
    x[,i] = cut(x[,i], br=item.cutpoints[,i], 
                            labels=FALSE, include.lowest=TRUE)
  }
  
  #x is an nobs by nvars matrix with item scores
  return(x)
}

# try function (4 latent variables, n = 200, with 2 and 4 answer categories)
MyDataGeneration(factors[1], nobs[1], ncat = 2)
MyDataGeneration(factors[1], nobs[1], ncat = 4)

data1 <- MyDataGeneration(factors = 2, nobs = 50, ncat = 2)
model1 <- lavaan.data.syn1(2,12)

##################################### Model building ######################################
#for correctly specified model
lavaan.data.syn1 <- function(fact=1, nitems=6) {
  TXT <- ""
  for(k in 1:fact) {
    if(k==1){J <- paste0("F", k, " =~ ",
                         paste0("X", (k-1)*nitems + 1:nitems, collapse=" + "))}
    
    if(k>1){J <- rbind (J, K <- paste0("F", k, " =~ ",
                                       paste0("X", (k-1)*nitems + 1:nitems, collapse=" + ")))}
    TXT <- J
  }
  TXT
}

#try function
lavaan.data.syn1(4, 24)

#for the misspecified model
lavaan.data.syn2 <- function(fact=1, nitems=6) {
  TXT <- ""
  for(k in 1:fact) {
    if(k==1){J <- paste0("F", k, " =~ ",
                         paste0("X", (k-1)*nitems + 1:nitems, collapse=" + "))}
    
    if(k==2|k==4|k==6|k==8){ J <- paste0("F", k, " =~ ",
                                         paste0("X", ((k-1)*nitems)-1 + 1:(nitems+1), collapse=" + "))}
    
    if(k==3|k==5|k==7){J <- paste0("F", k, " =~ ",
                                   paste0("X", (k-1)*nitems + 1:nitems, collapse=" + "))}
    TXT <- rbind(TXT,J)
  }
  TXT
}

#try function
lavaan.data.syn2(4, 24)

##################################### Simulation ######################################

Truntime1 <- TG2sum1 <- TG2_1 <- TChi_1 <- TThres1 <- TExpect1 <- TObserved1 <- TPhi1 <- TLambda1 <- TSE1 <- Tprobs1 <-NULL
Truntime2 <- TG2sum2 <- TG2_2 <- TChi_2 <- TThres2 <- TExpect2 <- TObserved2 <- TPhi2 <- TLambda2 <-  TSE2 <- Tprobs2 <-NULL

# number of replications
n.replications <- 500

#create and locate directories
al.dir <- getwd()
dir.create("P2V2DATA24",showWarnings=F)
dir.create("P2V2RES24",showWarnings=F)
da.dir <- paste(al.dir,"/P2V2DATA24",sep="")
re.dir <- paste(al.dir,"/P2V2RES24",sep="")

jj <- 1  #Start; j=the dataset
repeat{
  
  #generate random seed
  seednr <- jj+2000; #draw a random seed 			
  set.seed(seednr[length(seednr)])
  cat("\n",jj,"\t") 	#Random number generation
  
  #initialize values (must be changed into rows of the design matrix)
  nvarp <- 6
  fact <- 4
  nvar<-nvarp*fact
  ncat <- 2 
  
  #generate data
  manifest.data <- MyDataGeneration(factors = 4, nobs = 200, ncat = 2)				       
  data.name <- paste("data",jj,fact,".dat",sep="")
  
  
  # create file with correct name and save it in the folder
  write(t(as.matrix(manifest.data)),
        file=paste(da.dir,"/",data.name,sep=""),
        ncolumns=ncol(manifest.data)) #write data

  ######################### RUN MODELS ###############################
  # Method old (WLSMV)
  fit1_W <- cfa( model <- lavaan.data.syn1(fact), data=manifest.data, std.lv=TRUE, ordered=c(colnames(manifest.data)),estimator="WLSMV")
  O1_W <- lavTables(fit1_W)
  
  #model with misspecifications
  fit2_W <- cfa( model <- lavaan.data.syn2(fact), data=manifest.data, std.lv=TRUE, ordered=c(colnames(manifest.data)),estimator="WLSMV")
  O2_W <- lavTables(fit2_W)
  
  # Method new (PML)
  #model without misspecifications
  fit1_P <- cfa( model <- lavaan.data.syn1(fact), data=manifest.data, std.lv=TRUE, ordered=c(colnames(manifest.data)),estimator="PML")	  
  O1_P <- lavTables(fit1_P)

  #model with misspecifications
  fit2_P <- cfa( model <- lavaan.data.syn2(fact), data=manifest.data, std.lv=TRUE, ordered=c(colnames(manifest.data)),estimator="PML")
  O2_W <- lavTables(fit2_P)
  
  ### TIME
  if(fit1_W@Fit@converged==TRUE){
    runtime1_W <- fit1_W@timing$total}
  if(fit2_W@Fit@converged==TRUE){
    runtime2_W <- fit2_W@timing$total}
  if(fit1_P@Fit@converged==TRUE){
    runtime1_P <- fit1_P@timing$total}
  if(fit2_P@Fit@converged==TRUE){
    runtime2_P <- fit2_P@timing$total}
  
  #Converge is true -> save time
  #Add natural break if not converged
  
    
  # estimated loadings
    L1_W <- matrix(fit1_W@Model@GLIST$lambda,nrow=1,byrow=TRUE)
    L2_W <- matrix(fit2_W@Model@GLIST$lambda,nrow=1,byrow=TRUE)
    L1_P <- matrix(fit1_P@Model@GLIST$lambda,nrow=1,byrow=TRUE)
    L2_P <- matrix(fit2_P@Model@GLIST$lambda,nrow=1,byrow=TRUE)
    
    #save lambda
    Lambda1 <- NULL
    for (i in 1:length(L)){if (L[,i] != 0){ Lambda1 <- cbind(Lambda1,L[,i])}}
    colnames(Lambda1) <- rep(paste("L",1:length(Lambda1),sep=""))
    Phi1 <- matrix(fit1_W@Model@GLIST$psi[lower.tri(fit1_W@Model@GLIST$psi)],nrow=1)
    colnames(Phi1) <- rep(paste("Ph",1:length(Phi1),sep=""))
    Thres1 <- matrix(fit1_W@Model@GLIST$tau,nrow=1)
    colnames(Thres1) <- rep(paste("T",1:length(Thres1),sep=""))
    K <- matrix(fit1_W@Fit@se,nrow=1)
    
    #save SE
    SE1 <- NULL
    for (i in 1:length(K)){if (K[,i] != 0){ SE1 <- cbind(SE1,K[,i])}}
    colnames(SE1)<- c(rep(paste("SeL",1:length(Lambda1))),rep(paste("SeT",1:length(Thres1))),rep(paste("SeP",1:length(Phi1))))
    
    #collect results
    Truntime1 <- rbind(Truntime1,cbind(jj,runtime1))
    TExpect1 <- rbind(TExpect1,cbind(jj,Expect1))
    TObserved1 <- rbind(TObserved1,cbind(jj,Observed))
    Tprobs1 <- rbind(Tprobs1,cbind(jj,probs1))
    TG2_1 <- rbind(TG2_1,cbind(jj,Gsq1))
    TChi_1 <- rbind(TChi_1,cbind(jj,CHIsq1))
    TPhi1  <- rbind(TPhi1 ,cbind(jj,Phi1))
    TLambda1  <- rbind(TLambda1 ,cbind(jj,Lambda1))
    TThres1  <- rbind(TThres1 ,cbind(jj,Thres1))
    TSE1  <- rbind(TSE1 ,cbind(jj,SE1))
  
  if(fit2@Fit@converged==TRUE){
    runtime2 <- fit2_W@timing$total
  }

    
    #collect results
    Truntime2 <- rbind(Truntime2,cbind(jj,runtime2))
    TExpect2 <- rbind(TExpect2,cbind(jj,Expect2))
    TObserved2 <- rbind(TObserved2,cbind(jj,Observed))
    Tprobs2 <- rbind(Tprobs2,cbind(jj,probs2))
    TG2_2 <- rbind(TG2_2,cbind(jj,Gsq2))
    TChi_2 <- rbind(TChi_2,cbind(jj,CHIsq2))
    TPhi2  <- rbind(TPhi2 ,cbind(jj,Phi2))
    TLambda2  <- rbind(TLambda2 ,cbind(jj,Lambda2))
    TThres2  <- rbind(TThres2 ,cbind(jj,Thres2))
    TSE2  <- rbind(TSE2 ,cbind(jj,SE2))

  
  jj <- jj+1 
  if(jj>n.replications) break
  }


####save in list
Output <- list(Misspecified=list(Truntime1, 
                  TExpect1, 
                  TObserved1, 
                  Tprobs1,
                  TG2_1,
                  TChi_1,
                  TThres1, 
                  TPhi1,
                  TLambda1,
                  TSE1),
Corspecified=list(Truntime2, 
                  TExpect2, 
                  TObserved2, 
                  Tprobs2,
                  TG2_2,
                  TChi_2,
                  TThres2, 
                  TPhi2,
                  TLambda2,
                  TSE2)
)

setwd(re.dir)
save(Output, file="output.Rdata") #save workspace with all results

save.image("ALL") 
