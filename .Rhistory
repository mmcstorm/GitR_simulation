x
x$X7
if (x$X7, x$X8, x$X9, x$X10, x$X11, x$X12){
for(i in 1:ncol(item.cutpoints)){
x[,i] = cut(x[,i], br=item.cutpoints[,i],
labels=FALSE, include.lowest=TRUE)
}
}
MyDataGeneration <- function(factors, nobs, nvarp = 6, data_type) {
# model specifications
nvar <- factors*nvarp
BM <- matrix(c(.8,.8,.7,.7,.6,.6),nrow=1) #factor loadings
r <- 0.3 # correlation between latent variables
int <- c(0,0,0,0,0,0) # intercept
s <- matrix(r, factors, factors)
diag(s) <- 1
# intercepts of the items
int2 <- rep(int,factors)
# b is the loadingsmatrix > transposed matrix version
b <- t(kronecker(diag(factors), BM)) # kronecker computes product of two arrays
# add crossloadings (misspecifications)
x.mis <- sapply(1:(factors/2), function(x) return(6 + 12*(x-1)))
y.mis <- sapply(1:(factors/2), function(x) return(2 + 2*(x-1)))
b[x.mis, y.mis] <- .2
#compute error values (theta matrix)
ev <- diag(1 - diag(b %*% s %*% t(b)))
#compute sigma (variance-covariance matrix)
SIGMA <- b %*% s %*% t(b) + ev  #1's on the diagonal
#simulate data from a Multivariate Normal Distribution
x <- data.frame(MASS:::mvrnorm(n = nobs, mu = int2, Sigma = SIGMA))
item.cutpoints <-
matrix(c(rep(-1.20,nvar),rep(0,nvar),
rep(1.20,nvar)), ncol=nvar, byrow=TRUE)
#item cutpoints (add boundaries)
item.cutpoints <- rbind(rep(-Inf, ncol(item.cutpoints)),
item.cutpoints, rep(Inf, ncol(item.cutpoints)))
if (x$X7, x$X8, x$X9, x$X10, x$X11, x$X12){
for(i in 1:ncol(item.cutpoints)){
x[,i] = cut(x[,i], br=item.cutpoints[,i],
labels=FALSE, include.lowest=TRUE)
}
}
#x is an nobs by nvars matrix with item scores
return(x)
}
MyDataGeneration <- function(factors, nobs, nvarp = 6, data_type) {
# model specifications
nvar <- factors*nvarp
BM <- matrix(c(.8,.8,.7,.7,.6,.6),nrow=1) #factor loadings
r <- 0.3 # correlation between latent variables
int <- c(0,0,0,0,0,0) # intercept
s <- matrix(r, factors, factors)
diag(s) <- 1
# intercepts of the items
int2 <- rep(int,factors)
# b is the loadingsmatrix > transposed matrix version
b <- t(kronecker(diag(factors), BM)) # kronecker computes product of two arrays
# add crossloadings (misspecifications)
x.mis <- sapply(1:(factors/2), function(x) return(6 + 12*(x-1)))
y.mis <- sapply(1:(factors/2), function(x) return(2 + 2*(x-1)))
b[x.mis, y.mis] <- .2
#compute error values (theta matrix)
ev <- diag(1 - diag(b %*% s %*% t(b)))
#compute sigma (variance-covariance matrix)
SIGMA <- b %*% s %*% t(b) + ev  #1's on the diagonal
#simulate data from a Multivariate Normal Distribution
x <- data.frame(MASS:::mvrnorm(n = nobs, mu = int2, Sigma = SIGMA))
item.cutpoints <-
matrix(c(rep(-1.20,nvar),rep(0,nvar),
rep(1.20,nvar)), ncol=nvar, byrow=TRUE)
#item cutpoints (add boundaries)
item.cutpoints <- rbind(rep(-Inf, ncol(item.cutpoints)),
item.cutpoints, rep(Inf, ncol(item.cutpoints)))
if (x$X7, x$X8, x$X9, x$X10, x$X11, x$X12){
for(i in 1:ncol(item.cutpoints)){
x[,i] = cut(x[,i], br=item.cutpoints[,i],
labels=FALSE, include.lowest=TRUE)
}
}
#x is an nobs by nvars matrix with item scores
return(x)
}
MyDataGeneration <- function(factors, nobs, nvarp = 6, data_type) {
# model specifications
nvar <- factors*nvarp
BM <- matrix(c(.8,.8,.7,.7,.6,.6),nrow=1) #factor loadings
r <- 0.3 # correlation between latent variables
int <- c(0,0,0,0,0,0) # intercept
s <- matrix(r, factors, factors)
diag(s) <- 1
# intercepts of the items
int2 <- rep(int,factors)
# b is the loadingsmatrix > transposed matrix version
b <- t(kronecker(diag(factors), BM)) # kronecker computes product of two arrays
# add crossloadings (misspecifications)
x.mis <- sapply(1:(factors/2), function(x) return(6 + 12*(x-1)))
y.mis <- sapply(1:(factors/2), function(x) return(2 + 2*(x-1)))
b[x.mis, y.mis] <- .2
#compute error values (theta matrix)
ev <- diag(1 - diag(b %*% s %*% t(b)))
#compute sigma (variance-covariance matrix)
SIGMA <- b %*% s %*% t(b) + ev  #1's on the diagonal
#simulate data from a Multivariate Normal Distribution
x <- data.frame(MASS:::mvrnorm(n = nobs, mu = int2, Sigma = SIGMA))
item.cutpoints <-
matrix(c(rep(-1.20,nvar),rep(0,nvar),
rep(1.20,nvar)), ncol=nvar, byrow=TRUE)
#item cutpoints (add boundaries)
item.cutpoints <- rbind(rep(-Inf, ncol(item.cutpoints)),
item.cutpoints, rep(Inf, ncol(item.cutpoints)))
if (x$X7, x$X8, x$X9, x$X10, x$X11, x$X12){
for(i in 1:ncol(item.cutpoints)){
x[,i] = cut(x[,i], br=item.cutpoints[,i],
labels=FALSE, include.lowest=TRUE)
}
}
#x is an nobs by nvars matrix with item scores
return(x)
}
# load packages
library(lavaan)
library(usethis)
RowOfDesign <- 1
Replication <- 1
############################# Simulation Design  #############################
factors <- c(2,4,6,8) 					            #number of latent variables
nobs <- c(200,400,800)                      #sample size
ncat <- c(2,4)                              #number of categories
Design <- expand.grid(factors = factors, nobs = nobs, ncat = ncat)
MyDataGeneration <- function(factors, nobs, ncat, nvarp = 6) {
# model specifications
nvar <- factors*nvarp
BM <- matrix(c(.8,.8,.7,.7,.6,.6),nrow=1) #factor loadings
r <- 0.3 # correlation between latent variables
int <- c(0,0,0,0,0,0) # intercept
s <- matrix(r, factors, factors)
diag(s) <- 1
# intercepts of the items
int2 <- rep(int,factors)
# b is the loadingsmatrix > transposed matrix version
b <- t(kronecker(diag(factors), BM)) # kronecker computes product of two arrays
# add crossloadings (misspecifications)
x.mis <- sapply(1:(factors/2), function(x) return(6 + 12*(x-1)))
y.mis <- sapply(1:(factors/2), function(x) return(2 + 2*(x-1)))
b[x.mis, y.mis] <- .2
#compute error values (theta matrix)
ev <- diag(1 - diag(b %*% s %*% t(b)))
#compute sigma (variance-covariance matrix)
SIGMA <- b %*% s %*% t(b) + ev  #1's on the diagonal
#simulate data from a Multivariate Normal Distribution
x <- data.frame(MASS:::mvrnorm(n = nobs, mu = int2, Sigma = SIGMA))
# for 2 answer categories (1 threshold -> 0)
if (ncat==2) {item.cutpoints <-
matrix(c(rep(0,nvar)), ncol=nvar, byrow=TRUE)}
# for 4 answer categories (3 thresholds -> -1.2, 0, 1.2)
if (ncat==4) {item.cutpoints <-
matrix(c(rep(-1.20,nvar),rep(0,nvar),
rep(1.20,nvar)), ncol=nvar, byrow=TRUE)}
#item cutpoints (add boundaries)
item.cutpoints <- rbind(rep(-Inf, ncol(item.cutpoints)),
item.cutpoints, rep(Inf, ncol(item.cutpoints)))
for(i in 1:ncol(item.cutpoints)){
x[,i] = cut(x[,i], br=item.cutpoints[,i],
labels=FALSE, include.lowest=TRUE)
}
#x is an nobs by nvars matrix with item scores
return(x)
}
# Colnames Generator
ColnamesGeneratorEst <- function(method, specif, facts, ncat){
if(facts %% 2 != 0){stop("Amount of factors should be an even number!")}
if(specif == "MS"){
x.mis <- sapply(1:(facts/2), function(x) return(6 + 12*(x-1))) + seq(1, facts/2, 1)
len <- facts*6.5
lambs <- character(len)
lambs[-x.mis] <- paste("L", 1:(facts*6), sep = "")
lambs[x.mis] <- paste("L", letters[1:(facts/2)], sep = "")
}
else{
lambs <- paste("L", 1:(facts*6), sep = "")
}
if (ncat == 4){
thres <- paste("T", 'i', 1:(facts*6), sep = "")
thres <- paste(rep(thres, each = 3), letters[1:3])
}
else{
thres <- paste("T", 'i', 1:(facts*6), sep = "")
}
ncovs <- max(cumsum(seq(1,1 +4*(facts/2-1), 4)))
covs <- paste("C", 1:ncovs, sep = "")
out_vec <- c(lambs, thres, covs)
return(paste(method, specif, out_vec, sep = "_"))
}
ColnamesGeneratorSE <- function(method, specif, facts, ncat){
if(facts %% 2 != 0){stop("Amount of factors should be an even number!")}
if(specif == "MS"){
x.mis <- sapply(1:(facts/2), function(x) return(6 + 12*(x-1))) + seq(1, facts/2, 1)
len <- facts*6.5
lambs <- character(len)
lambs[-x.mis] <- paste("L_SE", 1:(facts*6), sep = "")
lambs[x.mis] <- paste("L_SE", letters[1:(facts/2)], sep = "")
}
else{
lambs <- paste("L_SE", 1:(facts*6), sep = "")
}
if (ncat == 4){
thres <- paste("T_SE", 'i', 1:(facts*6), sep = "")
thres <- paste(rep(thres, each = 3), letters[1:3])
}
else{
thres <- thres <- paste("T_SE", 'i', 1:(facts*6), sep = "")
}
ncovs <- max(cumsum(seq(1,1 +4*(facts/2-1), 4)))
covs <- paste("C_SE", 1:ncovs, sep = "")
out_vec <- c(lambs, thres, covs)
return(paste(method, specif, out_vec, sep = "_"))
}
### Model building
# correctly specified model
lavaan.data.syn1 <- function(fact=1, nitems=6) {
TXT <- ""
for(j in 1:fact) {
if(j==1){J <- paste0("F", j, " =~ ",
paste0("X", (j-1)*nitems + 1:nitems, collapse=" + "))}
if(j>1){J <- rbind (J, K <- paste0("F", j, " =~ ",
paste0("X", (j-1)*nitems + 1:nitems, collapse=" + ")))}
TXT <- J
}
TXT
}
# misspecified model
lavaan.data.syn2 <- function(fact=1, nitems=6) {
TXT <- ""
for(j in 1:fact) {
if(j==1){J <- paste0("F", j, " =~ ",
paste0("X", (j-1)*nitems + 1:nitems, collapse=" + "))}
if(j==2|j==4|j==6|j==8){ J <- paste0("F", j, " =~ ",
paste0("X", ((j-1)*nitems)-1 + 1:(nitems+1), collapse=" + "))}
if(j==3|j==5|j==7){J <- paste0("F", j, " =~ ",
paste0("X", (j-1)*nitems + 1:nitems, collapse=" + "))}
TXT <- rbind(TXT,J)
}
TXT
}
################################ Simulation start (1 cell) ##########################
MySimulationCell<- function(Design = Design, RowOfDesign, Z){
# initialize values
nvarp <- 6
fact <- Design[RowOfDesign,1]
nvar <- nvarp*fact
# Create matrices to store the results:
## WLS_CS
MyResult_WLS_CS_est <- matrix(NA,
nrow = Z,
ncol = length(ColnamesGeneratorEst("WLS",
"CS",
fact,
Design[RowOfDesign,3])))
colnames(MyResult_WLS_CS_est) <- ColnamesGeneratorEst("WLS","CS",fact,Design[RowOfDesign,3])
MyResult_WLS_CS_err <- matrix(NA,
nrow = Z,
ncol = length(ColnamesGeneratorSE("WLS",
"CS",
fact,
Design[RowOfDesign,3])))
colnames(MyResult_WLS_CS_err) <- ColnamesGeneratorSE("WLS","CS",fact,Design[RowOfDesign,3])
MyResult_WLS_CS_FI <- matrix(NA, nrow = Z, ncol = 5)
colnames(MyResult_WLS_CS_FI) <- c("chisq.scaled", "df.scaled",
"pvalue.scaled", "cfi.scaled",
"rmsea.scaled")
## WLS_MS
MyResult_WLS_MS_est <- matrix(NA,
nrow = Z,
ncol = length(ColnamesGeneratorEst("WLS",
"MS",
fact,
Design[RowOfDesign,3])))
colnames(MyResult_WLS_MS_est) <- ColnamesGeneratorEst("WLS","MS",fact,Design[RowOfDesign,3])
MyResult_WLS_MS_err <- matrix(NA,
nrow = Z,
ncol = length(ColnamesGeneratorSE("WLS",
"MS",
fact,
Design[RowOfDesign,3])))
colnames(MyResult_WLS_MS_err) <- ColnamesGeneratorSE("WLS","MS",fact,Design[RowOfDesign,3])
MyResult_WLS_MS_FI <- matrix(NA, nrow = Z, ncol = 5)
colnames(MyResult_WLS_MS_FI) <- c("chisq.scaled", "df.scaled",
"pvalue.scaled", "cfi.scaled",
"rmsea.scaled")
## PML_CS
MyResult_PML_CS_est <- matrix(NA,
nrow = Z,
ncol = length(ColnamesGeneratorEst("PML",
"CS",
fact,
Design[RowOfDesign,3])))
colnames(MyResult_PML_CS_est) <- ColnamesGeneratorEst("PML","CS",fact,Design[RowOfDesign,3])
MyResult_PML_CS_err <- matrix(NA,
nrow = Z,
ncol = length(ColnamesGeneratorSE("PML",
"CS",
fact,
Design[RowOfDesign,3])))
colnames(MyResult_PML_CS_err) <- ColnamesGeneratorSE("PML","CS",fact,Design[RowOfDesign,3])
MyResult_PML_CS_FI <- matrix(NA, nrow = Z, ncol = 5)
colnames(MyResult_PML_CS_FI) <- c("chisq.scaled", "df.scaled",
"pvalue.scaled", "cfi.scaled",
"rmsea.scaled")
## PML_MS
MyResult_PML_MS_est <- matrix(NA,
nrow = Z,
ncol = length(ColnamesGeneratorEst("PML",
"MS",
fact,
Design[RowOfDesign,3])))
colnames(MyResult_PML_MS_est) <- ColnamesGeneratorEst("PML","MS",fact,Design[RowOfDesign,3])
MyResult_PML_MS_err <- matrix(NA,
nrow = Z,
ncol = length(ColnamesGeneratorSE("PML",
"MS",
fact,
Design[RowOfDesign,3])))
colnames(MyResult_PML_MS_err) <- ColnamesGeneratorSE("PML","MS",fact,Design[RowOfDesign,3])
MyResult_PML_MS_FI <- matrix(NA, nrow = Z, ncol = 5)
colnames(MyResult_PML_MS_FI) <- c("chisq.scaled", "df.scaled",
"pvalue.scaled", "cfi.scaled",
"srmr")
#create a loop over the replications z = 1 to Z:
tmp <- proc.time()
input<- cbind(seq(1,550), rep(0,550))
mis500<- as.matrix(input)
for (z in 1:Z){
# Generate data
# set a random number seed to be able to replicate the result exactly
set.seed((z + 1000)*RowOfDesign)
SimDat <- do.call(MyDataGeneration, Design[RowOfDesign,] )
## WLS correctly specified model
fit1_W <- try(cfa( model <- lavaan.data.syn1(fact),
data=SimDat, std.lv=TRUE,
ordered=c(colnames(SimDat)), #Simdat?
estimator="WLSMV"),silent=TRUE)
if(inherits(fit1_W, "try-error")) {
mis500[z,1] <- 1
} else {
# parameter estimates
index <- which(fit1_W@ParTable$free != 0)
MyAnalysisResult_WLS1est <- fit1_W@ParTable$est[index]
MyResult_WLS_CS_est[z, ] <- MyAnalysisResult_WLS1est
# standard errors
MyAnalysisResult_WLS1err <- fit1_W@ParTable$se[index]
MyResult_WLS_CS_err[z, ] <- MyAnalysisResult_WLS1err
### FITINDICES
FI_WLS_CS <- fitMeasures(fit1_W, c("chisq.scaled","df.scaled",
"pvalue.scaled", "cfi.scaled", "srmr"))
MyResult_WLS_CS_FI[z,] <- FI_WLS_CS
}
## WLS misspecified model
fit2_W <- try(cfa( model <- lavaan.data.syn2(fact),
data=SimDat, std.lv=TRUE,
ordered=c(colnames(SimDat)),
estimator="WLSMV"),silent=TRUE)
if(inherits(fit2_W, "try-error")) {
mis500[z,2] <- 1
} else {
# parameter estimates
index <- which(fit2_W@ParTable$free != 0)
MyAnalysisResult_WLS2est <- fit2_W@ParTable$est[index]
names(MyAnalysisResult_WLS2est) <- ColnamesGeneratorEst("WLS",
"MS",
fact,
Design[RowOfDesign,3])
MyResult_WLS_MS_est[z, ] <- MyAnalysisResult_WLS2est
# standard errors
MyAnalysisResult_WLS2err <- fit2_W@ParTable$se[index]
names(MyAnalysisResult_WLS2err) <- ColnamesGeneratorSE("WLS",
"MS",
fact,
Design[RowOfDesign,3])
MyResult_WLS_MS_err[z, ] <- MyAnalysisResult_WLS2err
### FITINDICES
FI_WLS_MS <-fitMeasures(fit2_W, c("chisq.scaled","df.scaled",
"pvalue.scaled", "cfi.scaled", "srmr"))
MyResult_WLS_MS_FI[z,] <- FI_WLS_MS
}
## PML correctly specified model
fit1_P <- try(cfa( model <- lavaan.data.syn1(fact),
data=SimDat, std.lv=TRUE,
ordered=c(colnames(SimDat)), #Simdat?
estimator="PML"),silent=TRUE)
if(inherits(fit1_P, "try-error")) {
mis500[z,2] <- 1
} else {
# parameter estimates
index <- which(fit1_P@ParTable$free != 0)
MyAnalysisResult_PML1est <- fit1_P@ParTable$est[index]
names(MyAnalysisResult_PML1est) <- ColnamesGeneratorEst("PML",
"CS",
fact,
Design[RowOfDesign,3])
MyResult_PML_CS_est[z, ] <- MyAnalysisResult_PML1est
# standard errors
MyAnalysisResult_PML1err <- fit1_P@ParTable$se[index]
names(MyAnalysisResult_PML1err) <- ColnamesGeneratorSE("PML",
"CS",
fact,
Design[RowOfDesign,3])
MyResult_PML_CS_err[z, ] <- MyAnalysisResult_PML1err
### FITINDICES
FI_PML_CS <- fitMeasures(fit1_P,
c("chisq.scaled","df.scaled",
"pvalue.scaled", "cfi.scaled", "srmr"))
MyResult_PML_CS_FI[z,] <- FI_PML_CS
}
#PML misspecified model
fit2_P <- try(cfa( model <- lavaan.data.syn2(fact),
data=SimDat, std.lv=TRUE,
ordered=c(colnames(SimDat)), #Simdat?
estimator="PML"),silent=TRUE)
if(inherits(fit2_P, "try-error")) {
mis500[z,2] <- 1
z <- z+1
} else {
# parameter estimates
index <- which(fit2_P@ParTable$free != 0)
MyAnalysisResult_PML2est <- fit2_P@ParTable$est[index]
names(MyAnalysisResult_PML2est) <- ColnamesGeneratorEst("PML",
"MS",
fact,
Design[RowOfDesign,3])
MyResult_PML_MS_est[z, ] <- MyAnalysisResult_PML2est
# standard errors
MyAnalysisResult_PML2err <- fit2_P@ParTable$se[index]
names(MyAnalysisResult_PML2err) <- ColnamesGeneratorSE("PML",
"MS",
fact,
Design[RowOfDesign,3])
MyResult_PML_MS_err[z, ] <- MyAnalysisResult_PML2err
### FITINDICES
FI_PML_MS <- fitMeasures(fit2_P, c("chisq.scaled","df.scaled",
"pvalue.scaled", "cfi.scaled", "srmr"))
MyResult_PML_MS_FI[z, ] <- FI_PML_MS
}
#save the time to run the analyses of K data sets in one cell of the design.
time <- proc.time() - tmp
}
# save all relevant results
return(list(MyResult_WLS_CS_est = MyResult_WLS_CS_est,
MyResult_WLS_CS_err = MyResult_WLS_CS_err,
MyResult_WLS_CS_FI = MyResult_WLS_CS_FI,
MyResult_WLS_MS_est = MyResult_WLS_MS_est,
MyResult_WLS_MS_err = MyResult_WLS_MS_err,
MyResult_WLS_MS_FI = MyResult_WLS_MS_FI,
MyResult_PML_CS_est = MyResult_PML_CS_est,
MyResult_PML_CS_err = MyResult_PML_CS_err,
MyResult_PML_CS_FI = MyResult_PML_CS_FI,
MyResult_PML_MS_est = MyResult_PML_MS_est,
MyResult_PML_MS_err = MyResult_PML_MS_err,
MyResult_PML_MS_FI = MyResult_PML_MS_FI,
time = time,
mis500 = mis500))
}
# collect data
MyResult_onecell <- MySimulationCell(Design, RowOfDesign = 1, Z = 2)
MyResult_onecell
################################ Simulation all cells  ###############################
TotalCells <- nrow(Design)
for (i in 1:TotalCells){
Row <- i
MyResult <- MySimulationCell(Design = Design, RowOfDesign = Row, Z = 2) #10!
# Write output of one cell of the design
# Save WLS results
MyResult1 <- MyResult[1]
write.csv(MyResult1,
file = paste("WLS_CS_est", "Row", Row,".csv" , sep = ""))
MyResult2 <- MyResult[2]
write.csv(MyResult2,
file = paste("WLS_CS_err", "Row", Row,".csv" , sep =""))
MyResult3 <- MyResult[3]
write.csv(MyResult3,
file =paste("FI_WLS_CS", "Row", Row, ".csv" , sep =""))
MyResult4 <- MyResult[4]
write.csv(MyResult4,
file = paste("WLS_MS_est", "Row", Row,".csv" , sep =""))
MyResult5 <- MyResult[5]
write.csv(MyResult5,
file = paste("WLS_MS_err", "Row", Row,".csv" , sep =""))
MyResults6 <- MyResult[6]
write.csv(MyResults6,
file =paste("FI_WLS_MS", "Row", Row, ".csv" , sep =""))
# Save PML results
MyResult7 <- MyResult[7]
write.csv(MyResult7,
file = paste("PML_CS_est", "Row", Row,".csv" , sep =""))
MyResult8 <- MyResult[8]
write.csv(MyResult8,
file = paste("PML_CS_err", "Row", Row,".csv" , sep =""))
MyResults9 <- MyResult[9]
write.csv(MyResults9,
file =paste("FI_PML_CS", "Row", Row, ".csv" , sep =""))
MyResult10 <- MyResult[10]
write.csv(MyResult10,
file = paste("PML_MS_est", "Row", Row,".csv" , sep =""))
MyResult11 <- MyResult[11]
write.csv(MyResult11,
file = paste("PML_MS_err", "Row", Row,".csv" , sep =""))
MyResults12 <- MyResult[12]
write.csv(MyResults12,
file =paste("FI_PML_MS", "Row", Row, ".csv" , sep =""))
# Save time
MyResults13 <- MyResult[13]
save(MyResults13, file =paste("Time", "Row", Row, ".Rdata" , sep =""))
}
